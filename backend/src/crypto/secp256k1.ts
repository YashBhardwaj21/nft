/**
 * SECP256K1 ELLIPTIC CURVE — Pure BigInt Implementation
 * ======================================================
 *
 * The secp256k1 curve used by Bitcoin and Ethereum.
 * Equation: y² ≡ x³ + 7 (mod p)
 *
 * This module contains ONLY math — no hashing, no signatures,
 * no Ethereum-specific logic. That lives in ecdsa.ts.
 *
 * All arithmetic uses native BigInt. No external libraries.
 */

// ============================================================================
// CURVE PARAMETERS
// ============================================================================

/** secp256k1 constants (from SEC2 v2, §2.4.1) */
export const CURVE = {
    /** Field prime — defines the finite field F_p */
    p: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2Fn,

    /** Curve order — number of points in the group generated by G */
    n: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n,

    /** Curve coefficient a (y² = x³ + ax + b) */
    a: 0n,

    /** Curve coefficient b */
    b: 7n,

    /** Generator point x-coordinate */
    Gx: 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798n,

    /** Generator point y-coordinate */
    Gy: 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8n,
};

/** Generator point G */
export const G: Point = { x: CURVE.Gx, y: CURVE.Gy };

// ============================================================================
// TYPES
// ============================================================================

/** Affine point on the curve */
export interface Point {
    x: bigint;
    y: bigint;
}

/** Identity element for point addition */
export const POINT_AT_INFINITY: Point = { x: 0n, y: 0n };

// ============================================================================
// MODULAR ARITHMETIC
// ============================================================================

/**
 * Safe modular reduction — always returns non-negative result.
 *
 * JavaScript BigInt `%` can return negative values for negative operands.
 * This normalizes: mod(-3, 5) = 2  (not -3).
 */
export function mod(a: bigint, m: bigint): bigint {
    return ((a % m) + m) % m;
}

/**
 * Modular multiplicative inverse via Extended Euclidean Algorithm.
 *
 * Finds x such that (a · x) ≡ 1 (mod m).
 * Required because division in a finite field is multiplication by inverse.
 */
export function modInverse(a: bigint, m: bigint): bigint {
    a = mod(a, m);

    let [oldR, r] = [a, m];
    let [oldS, s] = [1n, 0n];

    while (r !== 0n) {
        const q = oldR / r;
        [oldR, r] = [r, oldR - q * r];
        [oldS, s] = [s, oldS - q * s];
    }

    if (oldR !== 1n) throw new Error('modInverse: no inverse exists');
    return mod(oldS, m);
}

/**
 * Fast modular exponentiation via square-and-multiply.
 *
 * Computes (base^exp) mod m in O(log exp) multiplications.
 */
export function modPow(base: bigint, exp: bigint, m: bigint): bigint {
    if (exp < 0n) throw new Error('modPow: negative exponent');

    let result = 1n;
    base = mod(base, m);

    while (exp > 0n) {
        if (exp & 1n) result = mod(result * base, m);
        base = mod(base * base, m);
        exp >>= 1n;
    }

    return result;
}

/**
 * Modular square root for secp256k1.
 *
 * Since p ≡ 3 (mod 4), the square root of a is:
 *   sqrt(a) = a^((p+1)/4) mod p
 *
 * IMPORTANT: After computing the root, we VERIFY that root² ≡ a (mod p).
 * Without this check, invalid signatures can produce non-curve points.
 *
 * @throws if a is not a quadratic residue mod p
 */
export function sqrtMod(a: bigint): bigint {
    const root = modPow(a, (CURVE.p + 1n) / 4n, CURVE.p);

    // Verify: root² ≡ a (mod p)
    if (mod(root * root, CURVE.p) !== mod(a, CURVE.p)) {
        throw new Error('sqrtMod: value is not a quadratic residue mod p');
    }

    return root;
}

// ============================================================================
// POINT OPERATIONS
// ============================================================================

/** Check if a point represents the identity element */
export function isPointAtInfinity(p: Point): boolean {
    return p.x === 0n && p.y === 0n;
}

/**
 * Verify a point lies on secp256k1.
 *
 * Checks: y² ≡ x³ + 7 (mod p)
 * Also rejects coordinates outside [0, p).
 */
export function isOnCurve(p: Point): boolean {
    if (isPointAtInfinity(p)) return true;

    const { x, y } = p;
    if (x < 0n || x >= CURVE.p || y < 0n || y >= CURVE.p) return false;

    const lhs = mod(y * y, CURVE.p);
    const rhs = mod(x * x * x + CURVE.b, CURVE.p);
    return lhs === rhs;
}

/**
 * Double a point (P + P).
 *
 * λ = (3x² + a) / (2y)
 * x₃ = λ² − 2x
 * y₃ = λ(x − x₃) − y
 */
export function pointDouble(p: Point): Point {
    if (isPointAtInfinity(p) || p.y === 0n) return POINT_AT_INFINITY;

    const { x, y } = p;
    const num = mod(3n * x * x + CURVE.a, CURVE.p);
    const den = modInverse(2n * y, CURVE.p);
    const lam = mod(num * den, CURVE.p);

    const x3 = mod(lam * lam - 2n * x, CURVE.p);
    const y3 = mod(lam * (x - x3) - y, CURVE.p);
    return { x: x3, y: y3 };
}

/**
 * Add two distinct points (P + Q where P ≠ Q).
 *
 * λ = (y₂ − y₁) / (x₂ − x₁)
 * x₃ = λ² − x₁ − x₂
 * y₃ = λ(x₁ − x₃) − y₁
 *
 * Handles identity and inverse cases.
 */
export function pointAdd(p1: Point, p2: Point): Point {
    if (isPointAtInfinity(p1)) return p2;
    if (isPointAtInfinity(p2)) return p1;

    const { x: x1, y: y1 } = p1;
    const { x: x2, y: y2 } = p2;

    // Same point → double
    if (x1 === x2 && y1 === y2) return pointDouble(p1);

    // Inverse points → identity
    if (x1 === x2) return POINT_AT_INFINITY;

    // General case
    const num = mod(y2 - y1, CURVE.p);
    const den = modInverse(mod(x2 - x1, CURVE.p), CURVE.p);
    const lam = mod(num * den, CURVE.p);

    const x3 = mod(lam * lam - x1 - x2, CURVE.p);
    const y3 = mod(lam * (x1 - x3) - y1, CURVE.p);
    return { x: x3, y: y3 };
}

/**
 * Scalar multiplication via double-and-add.
 *
 * Computes k · P by scanning bits of k from LSB to MSB.
 *
 * Example: 13·P  (13 = 1101₂)
 *   = 1·P + 0·2P + 1·4P + 1·8P
 *   = P + 4P + 8P
 */
export function scalarMultiply(k: bigint, p: Point): Point {
    if (k === 0n || isPointAtInfinity(p)) return POINT_AT_INFINITY;

    // Reduce mod n to handle negative or oversized scalars
    let scalar = mod(k, CURVE.n);
    if (scalar === 0n) return POINT_AT_INFINITY;

    let result = POINT_AT_INFINITY;
    let addend = p;

    while (scalar > 0n) {
        if (scalar & 1n) result = pointAdd(result, addend);
        addend = pointDouble(addend);
        scalar >>= 1n;
    }

    return result;
}
